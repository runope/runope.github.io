{"pages":[],"posts":[{"title":"so的装载与链接","text":"so的装载与链接整体流程1 do_dlopen调用 dl_open 后，中间经过 dlopen_ext, 到达第一个主要函数 do_dlopen: 123456789soinfo* do_dlopen(const char* name, int flags, const Android_dlextinfo* extinfo) { protect_data(PROT_READ | PROT_WRITE); soinfo* si = find_library(name, flags, extinfo); // 查找 SO if (si != NULL) { si-&gt;CallConstructors(); // 调用 SO 的 init 函数 } protect_data(PROT_READ); return si;} do_dlopen 调用了两个重要的函数，第一个是find_library, 第二个是 soinfo 的成员函数 CallConstructors，find_library 函数是 SO 装载链接的后续函数， 完成 SO 的装载链接后， 通过 CallConstructors 调用 SO 的初始化函数。 2 find_library_internalfind_library 直接调用了 find_library_internal，下面直接看 find_library_internal函数: 123456789101112131415static soinfo* find_library_internal(const char* name, int dlflags, const Android_dlextinfo* extinfo) { if (name == NULL) { return somain; } soinfo* si = find_loaded_library_by_name(name); // 判断 SO 是否已经加载 if (si == NULL) { TRACE(&quot;[ '%s' has not been found by name. Trying harder...]&quot;, name); si = load_library(name, dlflags, extinfo); // 继续 SO 的加载流程 } if (si != NULL &amp;&amp; (si-&gt;flags &amp; FLAG_LINKED) == 0) { DL_ERR(&quot;recursive link to \\&quot;%s\\&quot;&quot;, si-&gt;name); return NULL; } return si;} find_library_internal 首先通过 find_loaded_library_by_name 函数判断目标 SO 是否已经加载，如果已经加载则直接返回对应的soinfo指针，没有加载的话则调用 load_library 继续加载流程，下面看 load_library 函数。 3 load_library1234567891011121314151617181920212223242526272829static soinfo* load_library(const char* name, int dlflags, const Android_dlextinfo* extinfo) { int fd = -1; ... // Open the file. fd = open_library(name); // 打开 SO 文件，获得文件描述符 fd ElfReader elf_reader(name, fd); // 创建 ElfReader 对象 ... // Read the ELF header and load the segments. if (!elf_reader.Load(extinfo)) { // 使用 ElfReader 的 Load 方法，完成 SO 装载 return NULL; } soinfo* si = soinfo_alloc(SEARCH_NAME(name), &amp;file_stat); // 为 SO 分配新的 soinfo 结构 if (si == NULL) { return NULL; } si-&gt;base = elf_reader.load_start(); // 根据装载结果，更新 soinfo 的成员变量 si-&gt;size = elf_reader.load_size(); si-&gt;load_bias = elf_reader.load_bias(); si-&gt;phnum = elf_reader.phdr_count(); si-&gt;phdr = elf_reader.loaded_phdr(); ... if (!soinfo_link_image(si, extinfo)) { // 调用 soinfo_link_image 完成 SO 的链接过程 soinfo_free(si); return NULL; } return si;} load_library 函数呈现了 SO 装载链接的整个流程，主要有3步: 装载:创建ElfReader对象，通过 ElfReader 对象的 Load 方法将 SO 文件装载到内存 分配soinfo:调用 soinfo_alloc 函数为 SO 分配新的 soinfo 结构，并按照装载结果更新相应的成员变量 链接: 调用 soinfo_link_image 完成 SO 的链接 加固主要函数CallConstructors 在编译 SO 时，可以通过链接选项-init或是给函数添加属性__attribute__((constructor))来指定 SO 的初始化函数，这些初始化函数在 SO 装载链接后便会被调用，再之后才会将 SO 的 soinfo 指针返回给 dl_open 的调用者。SO 层面的保护手段，有两个介入点, 一个是 jni_onload, 另一个就是初始化函数，比如反调试、脱壳等，逆向分析时经常需要动态调试分析这些初始化函数。 完成 SO 的装载链接后，返回到 do_dlopen 函数, do_open 获得 find_library 返回的刚刚加载的 SO 的 soinfo，在将 soinfo 返回给其他模块使用之前，最后还需要调用 soinfo 的成员函数 CallConstructors。 123456789soinfo* do_dlopen(const char* name, int flags, const Android_dlextinfo* extinfo) {... soinfo* si = find_library(name, flags, extinfo); if (si != NULL) { si-&gt;CallConstructors(); } return si;...} CallConstructors 函数会调用 SO 的首先调用所有依赖的 SO 的 soinfo 的 CallConstructors 函数，接着调用自己的 soinfo 成员变量 init 和调用init_array 指定的函数，这两个变量在在解析 dynamic section 时赋值。 1234567891011121314void soinfo::CallConstructors() { //如果已经调用过，则直接返回 if (constructors_called) { return; } // 调用依赖 SO 的 Constructors 函数 get_children().for_each([] (soinfo* si) { si-&gt;CallConstructors(); }); // 调用 init_func CallFunction(&quot;DT_INIT&quot;, init_func); // 调用 init_array 中的函数 CallArray(&quot;DT_INIT_ARRAY&quot;, init_array, init_array_count, false);} 有了以上分析基础后，在需要动态跟踪初始化函数时，我们就知道可以将断点设在 do_dlopen 或是 CallConstructors。 ADD SHELL在病毒和版权保护领域，“壳”一直扮演着极为重要的角色。通过加壳可以对代码进行压缩和加密，同时再辅以虚拟化、代码混淆和反调试等手段，达到防止静态和动态分析。 在 Android 环境中，Native 层的加壳主要是针对动态链接库 SO，SO 加壳的示意图如下: 加壳工具、loader、被保护SO。 SO: 即被保护的目标 SO。 loader: 自身也是一个 SO，系统加载时首先加载 loader，loader 首先还原出经过加密、压缩、变换的 SO，再将 SO 加载到内存，并完成链接过程，使 SO 可以正常被其他模块使用。 加壳工具: 将被保护的 SO 加密、压缩、变换，并将结果作为数据与 loader 整合为 packed SO。 下面对 SO 加壳的关键技术进行简单介绍。 Loader执行时机Linker 加载完 loader 后，loader 需要将被保护的 SO 加载起来，这就要求 loader 的代码需要被执行，而且要在 被保护 SO 被使用之前，前文介绍了 SO 的初始化函数便可以满足这个要求，同时在 Android 系统下还可以使用 JNI_ONLOAD 函数，因此 loader 的执行时机有两个选择:- SO 的 init 或 initarray- jni_onload loader 完成 SO 的加载链接loader 开始执行后，首先需要在内存中还原出 SO，SO 可以是经过加密、压缩、变换等手段，也可已单纯的以完全明文的数据存储，这与 SO 加壳的技术没有必要的关系，在此不进行讨论。在内存中还原出 SO 后，loader 还需要执行装载和链接，这两个过程可以完全模仿 Linker 来实现，下面主要介绍一下相对 Linker，loader 执行这两个过程有哪些变化。 装载还原后的 SO 在内存中，所以装载时的主要变化就是从文件装载到从内存装载。Linker 在装载 PT_LAOD segment时，使用 SO 文件的描述符 fd： 123456void* seg_addr = mmap(reinterpret_cast&lt;void*&gt;(seg_page_start), file_length, PFLAGS_TO_PROT(phdr-&gt;p_flags), MAP_FIXED|MAP_PRIVATE, fd_, file_page_start); 按照 Linker 装载，PT_LAOD segment时，需要分为两步： 123456789 // 1、改用匿名映射 void* seg_addr = mmap(reinterpret_cast&lt;void*&gt;(seg_page_start), file_length, PFLAGS_TO_PROT(phdr-&gt;p_flags), MAP_FIXED|MAP_PRIVATE, -1, 0);// 2、将内存中的 segment 复制到映射的内存中memcpy(seg_addr+seg_page_offset, elf_data_buf + phdr-&gt;p_offset, phdr-&gt;p_filesz); 注意第2步复制 segment 时，目标地址需要加上 seg_page_offset，seg_page_offset 是 segment 相对与页面起始地址的偏移。其他的步骤基本按照 Linker 的实现即可，只需要将一些从文件读取修改为从内存读取，比如读 elfheader和program header时。 分配soinfosoinfo 保存了 SO 装载链接和运行时需要的所有信息，为了维护相关的信息，loader 可以照搬 Linker 的 soinfo 结构，用于存储中间信息，装载链接结束后，还需要将 soinfo 的信息修复到 Linker 维护的soinfo。 链接链接过程完全是操作内存，不论是从文件装载还是内存装载，链接过程都是一样，完全模仿 Linker 即可。另外链接后记得顺便调用 SO 初始化函数( init 和 init_array )。 soinfo 修复SO 加壳的最关键技术点在于 soinfo 的修复，由于 Linker 加载的是 loader，而实际对外使用的是被保护的 SO，所以 Linker 维护的 soinfo 可以说是错误，loader 需要将自己维护的 soinfo 中的部分信息导出给 Linker 的soinfo。 修复过程如下： 获取 Linker 维护的 soinfo，可以通过 dlopen 打开自己来获得：self_soinfo = dlopen(self)。 将 loader soinfo 中的信息导出到 self_soinfo，最简单粗暴的方式就是直接赋值，比如：self_soinfo.base = soinfo.base。需要导出的主要有以下几项： - SO地址范围：base、size、load_bias - 符号信息:sym_tab、str_tab、 - 符号查找信息：nbucket、nchain、bucket、chain - 异常处理：ARM_exidx、ARM_exidx_count Android Linker 与 SO 加壳技术 : https://blog.csdn.net/hgl868/article/details/52759921 IDA调试android so的.init_array数组：https://www.cnblogs.com/bingghost/p/6297325.html Android NDK中.init段和.init_array段函数的定义方式：https://www.dllhook.com/post/213.html Linker学习笔记：https://wooyun.js.org/drops/Android%20Linker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html","link":"/2020/10/23/Android%20Linker%20and%20%20SO%20Add%20Shell/"},{"title":"android trace","text":"Art trace ：hook artmethod JNI trace ： jnitrace libc trace：frida-trace syscall trace：strace https://mp.weixin.qq.com/s/PIiGZKW6oQnOAwlCqvcU0g Wallbreaker： https://github.com/hluwa/Wallbreaker 批量hook如何使用objection去批量hook和trace？比如一次性hook几千个类？ 把~/.objection/objection.log删掉； 到objection界面中运行android hooking list classes，列出所有的类； 对新生成的~/.objection/objection.log文件进行过滤，比如只关心http相关的。cat objection.log|grep -i http 将输出结果保存到一个excel列中，前面补全android hooking watch class xxxxx，另存为文本文件。如附件所示 加载这个文件：objection -g com.android.settings explore -c “2.txt” ，这样一下子就hook上了几千个相关类的所有方法及其所有重载。 如果trace感兴趣的方法也是同理，android hooking search methods * ，会打印出所有的方法。 frida Script延时注入（Latency injection）固定时间之后注入使用setTimeout() 方法,例如：3 秒（3000 毫秒）后弹出 “Hello” : 123456setTimeout(function(){ alert(&quot;Hello&quot;); }, 3000);// frida's javascriptsetImmediate(function () { setTimeout(native_hook, 5000)}) 在特定so库加载之后注入有的库在程序启动时，并不会立刻加载。我们直接hook会提示无法找到此库，这时我们可以借助dlopen函数，在so库加载完成之后再去hook。hook框架如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546Interceptor.attach(Module.findExportByName(null, &quot;dlopen&quot;), { onEnter: function (args) { this.path = Memory.readUtf8String(args[0]); console.log(&quot;[*] import :&quot; + this.path); }, onLeave: function (retval) { // libwukong_ua.so改为要hook的so库 if(!this.path.isNull() &amp;&amp; !retval.isNull() &amp;&amp; this.path.includes('libwukong_ua.so')) { // 匿名函数hook，libwukong_ua.so改为要hook的so库，'0x426DE0'为函数在ida中查看的偏移地址 var fstatat = resolveAddress('libwukong_ua.so', '0x0', '0x426DE0'); Interceptor.attach(fstatat, { onEnter: function (args) { console.log(&quot;======= used! ======&quot;) }, onLeave: function (retval) { } }); // 根据函数名Hook，'libwukong_ua.so'为库名, 'ssl3_send_client_certificate'为函数名 var fstatat = Module.findExportByName('libwukong_ua.so', 'ssl3_send_client_certificate'); Interceptor.attach(fstatat, { onEnter: function (args) { console.log(&quot;======= used! ======&quot;) }, onLeave: function (retval) { } }); } }});function resolveAddress(name, idaBase, idaAddr) { var baseAddr = Module.findBaseAddress(name); console.log('[+] BaseAddr of ' + name + ': ' + baseAddr); // Calculate offset in memory from base address in IDA database var offset = ptr(idaAddr).sub(idaBase); // Add current memory base address to offset of function to monitor var result = baseAddr.add(offset); // Write location of function in memory to console console.log('[+] Address in memory: ' + result); return result;} 格式化输出（Formatted printing）Hook动态注册方法frida hook libart(RegisterNatives)脚本详情见：https://github.com/lasting-yang/frida_hook_libart 123456789101112131415161718192021222324252627282930313233343536373839404142434445function hook_RegisterNatives() { var symbols = Module.enumerateSymbolsSync(&quot;libart.so&quot;); var addrRegisterNatives = null; for (var i = 0; i &lt; symbols.length; i++) { var symbol = symbols[i]; //_ZN3art3JNI15RegisterNativesEP7_JNIEnvP7_jclassPK15JNINativeMethodi if (symbol.name.indexOf(&quot;art&quot;) &gt;= 0 &amp;&amp; symbol.name.indexOf(&quot;JNI&quot;) &gt;= 0 &amp;&amp; symbol.name.indexOf(&quot;RegisterNatives&quot;) &gt;= 0 &amp;&amp; symbol.name.indexOf(&quot;CheckJNI&quot;) &lt; 0) { addrRegisterNatives = symbol.address; console.log(&quot;RegisterNatives is at &quot;, symbol.address, symbol.name); } } if (addrRegisterNatives != null) { Interceptor.attach(addrRegisterNatives, { onEnter: function (args) { console.log(&quot;[RegisterNatives] method_count:&quot;, args[3]); var env = args[0]; var java_class = args[1]; var class_name = Java.vm.tryGetEnv().getClassName(java_class); //console.log(class_name); var methods_ptr = ptr(args[2]); var method_count = parseInt(args[3]); for (var i = 0; i &lt; method_count; i++) { var name_ptr = Memory.readPointer(methods_ptr.add(i * Process.pointerSize * 3)); var sig_ptr = Memory.readPointer(methods_ptr.add(i * Process.pointerSize * 3 + Process.pointerSize)); var fnPtr_ptr = Memory.readPointer(methods_ptr.add(i * Process.pointerSize * 3 + Process.pointerSize * 2)); var name = Memory.readCString(name_ptr); var sig = Memory.readCString(sig_ptr); var find_module = Process.findModuleByAddress(fnPtr_ptr); console.log(&quot;[RegisterNatives] java_class:&quot;, class_name, &quot;name:&quot;, name, &quot;sig:&quot;, sig, &quot;fnPtr:&quot;, fnPtr_ptr, &quot;module_name:&quot;, find_module.name, &quot;module_base:&quot;, find_module.base, &quot;offset:&quot;, ptr(fnPtr_ptr).sub(find_module.base)); } } }); }}setImmediate(hook_RegisterNatives);","link":"/2020/10/23/android%20trace/"},{"title":"kali linux","text":"Root问题最好的解决思路：直接使用Root账户，但是途中还是有很多配置，下面具体讲这些步骤： 使用kali账户进入系统，修改root密码sudo passwd root 用root账户进入系统 解决terminal配色问题：cp /home/{your user name}/.bashrc /root/.bashrc 解决有些程序所属组问题， chown -R root:root /home/ chgrp -R root:root /home/ kali系统源12345678910mousepad /etc/apt/sources.list# add zju sourcedeb http://mirrors.zju.edu.cn/kali kali-rolling main contrib non-freedeb-src http://mirrors.zju.edu.cn/kali kali-rolling main contrib non-freeapt-get update &amp;apt-get upgradeapt-get dist-upgrade#删除以下载的包apt-get clean pip源1234# 如果要安装pipapt install python3-pip# 设置豆瓣源pip config set global.index-url https://pypi.douban.com/simple/ Terminal无法调整字体大小问题12345678修改配置文件，用户家目录下~/.config/qterminal.org/qterminal.ini下面两行，第一行是字体，第二行是大小fontFamily=Fira CodefontSize=10修改的时候要先把终端关闭了,直接用文件夹查看，View-》Show Hidden Files 安装小工具 两个文件比较工具：apt install kompare16进制查看工具：apt install bless16进制查看工具：自带的hexdump： hexdump -C -n 10 {filename} -n10指查看前10字节编辑十六进制： apt install hexeditRadare2Radare2教程：https://github.com/Maijin/radare2-workshop-2015 安装Ghidra其实，卡里内部已经有多个版本的jre，在目录/usr/lib/jvm/中，ghidra需要jdk11，我们只需要执行apt install default-jdk就能安装jdk11，之后./ghidraRun，输入路径/usr/lib/jvm/java-11-openjdk-amd64/即可","link":"/2020/10/23/kali%20linux/"},{"title":"blog搭建","text":"安装hexo1234添加国内镜像源安装hexo： npm i hexo-cli -g初始化文件夹： hexo init安装必备组件： npm install hexo常用命令 12345hexo g # 生成博客网页文件hexo s # 本地预览博客hexo d # 上传网页文件到githubhexo new post &quot;article title&quot; # 新建一篇文章(需要插件)hexo clean # 清除默认缓存 icarus主题安装1https://github.com/ppoffice/hexo-theme-icarus 参考链接12345https://big-news.cn/2019/08/12/hexo%E4%B8%BB%E9%A2%98Icarus%E6%B5%85%E5%BA%A6%E4%BF%AE%E6%94%B9%E6%95%99%E7%A8%8B/#%E7%AB%99%E7%82%B9%E6%8E%A8%E9%80%81https://www.cnblogs.com/KongkOngL/p/10449269.htmlhttps://susreal.com/article/2019/hexo-theme-icarus-3/https://www.imaegoo.com/2019/icarus-night-mode-2/https://blog.csdn.net/qq_41793001/article/details/103055201 next-Gemini主题配置下载next主题123$ cd hexo-site$ git clone https://github.com/next-theme/hexo-theme-next themes/nexticarus 主题https://github.com/ppoffice/hexo-theme-icarus 启用next​ （1）打开博客根目录下的_config.yml文件，将Theme修改为next–&gt; theme: next ​ （2）修改hexo默认风格，在themes/next/_config.yml中修改配置scheme: Gemini 添加社交帐号在themes/next/_config.yml中修改配置 12345678910111213141516171819202122232425# ---------------------------------------------------------------# Sidebar Settings# ---------------------------------------------------------------# Social Links.# Usage: `Key: permalink || icon`# Key is the link label showing to end users.# Value before `||` delimeter is the target permalink.social: GitHub: https://github.com/yourname || github E-Mail: mailto:yourname@gmail.com || envelope #Google: https://plus.google.com/yourname || google #Twitter: https://twitter.com/yourname || twitter #FB Page: https://www.facebook.com/yourname || facebook #VK Group: https://vk.com/yourname || vk #StackOverflow: https://stackoverflow.com/yourname || stack-overflow #YouTube: https://youtube.com/yourname || youtube #Instagram: https://instagram.com/yourname || instagram #Skype: skype:yourname?call|chat || skypesocial_icons: enable: true icons_only: false transition: false 文章字数统计安装插件： 1npm i --save hexo-wordcount 在themes/next/_config.yml中修改配置， 12345678# Post wordcount display settings# Dependencies: https://github.com/willin/hexo-wordcountpost_wordcount: item_text: true wordcount: true min2read: true totalcount: true separated_meta: true 打开 post.swig 文件，/themes/next/layout/_macro/post.swig，在对应数字后增加单位： 字数： 123&lt;span title=&quot;{{ __('post.wordcount') }}&quot;&gt; {{ wordcount(post.content) }} 字&lt;/span&gt; 阅读时长： 123&lt;span title=&quot;{{ __('post.min2read') }}&quot;&gt; {{ min2read(post.content) }} 分钟&lt;/span&gt; 添加站内搜索安装插件： 1npm install hexo-generator-search --save 在themes/next/_config.yml中修改配置： 123456789# Local search# Dependencies: https://github.com/flashlab/hexo-generator-searchlocal_search: enable: true # if auto, trigger search by changing input # if manual, trigger search by pressing enter key or search button trigger: auto # show top n results per article, show all results by setting to -1 top_n_per_article: 1 页面底部主题信息删除打开themes中的next文件夹，找到_config.yml文件，修改footer下面的配置为false即可。 12345678910copyright:# -------------------------------------------------------------# Hexo link (Powered by Hexo).powered: falsetheme: # Theme &amp; scheme info link (Theme - NexT.scheme). enable: false # Version info of NexT after scheme info (vX.X.X). version: false","link":"/2020/10/23/nexo_next_%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"title":"linux Socket","text":"基本的UDP Socket编程UDP通信的流程比较简单，因此要搭建这么一个常用的UDP通信框架也是比较简单的。以下是UDP的框架图。 由以上框图可以看出，客户端要发起一次请求，仅仅需要两个步骤（socket和sendto），而服务器端也仅仅需要三个步骤即可接收到来自客户端的消息（socket、bind、recvfrom）。 Send, sendto, 和 sendmsg 用于向另一个套接字传递消息. Send 仅仅用于连接套接字,而 sendto 和 sendmsg 可用于任何情况下. read()/write() recv()/send() readv()/writev() recvmsg()/sendmsg() recvfrom()/sendto() 目标地址用 to 指定, tolen 定义其长度.消息的长度用 len 指定. 如果消息太长不能通过下层协议,函数将返回 EMSGSIZE 错误,消息也不会被送出. 在数据传送过程中所产生的错误不会返回给 send. 如果发生本地错误,则返回-1. 当要发送的消息长度大于套接字当前可用缓冲区时, send 将阻塞,除非在套接字上设置了非阻塞式输入输出模式. 对于非阻塞模式,这种情况下将返回 EAGAIN 错误. udp的connect函数UDP网络编程中也有connect函数，但它仅仅用于表示确定了另一方的地址，并没有其他含义。有了以上认识后，我们可以知道UDP套接字有以下区分：1）未连接的UDP套接字2）已连接的UDP套接字 对于未连接的套接字，也就是我们常用的的UDP套接字，我们使用的是sendto/recvfrom进行信息的收发，目标主机的IP和端口是在调用sendto/recvfrom时确定的； 在一个未连接的UDP套接字上给两个数据报调用sendto函数内核将执行以下六个步骤：1）连接套接字2）输出第一个数据报3）断开套接字连接4）连接套接字5）输出第二个数据报6）断开套接字连接 对于已连接的UDP套接字，必须先经过connect来向目标服务器进行指定，然后调用read/write进行信息的收发，目标主机的IP和端口是在connect时确定的，也就是说，一旦connect成功，我们就只能对该主机进行收发信息了。 已连接的UDP套接字给两个数据报调用write函数内核将执行以下三个步骤：1）连接套接字2）输出第一个数据报3）输出第二个数据报 由此可以知道，当应用进程知道给同一个目的地址的端口号发送多个数据报时，显示套接字效率更高。 下面给出带connect函数的UDP通信框架 Socket端口通信运行在会话层，并不是应用层，Socket抓包的原理与应用层Http(s)有着显著的区别。准确的说，Http(s)抓包是真正的“中间人”抓包，而Socket抓包是在接口上进行转储；Http(s)抓包是明显的将一套C/S架构通信分裂成两套完整的通信过程，而Socket抓包是在接口上将发送与接收的内容存储下来，并不干扰其原本的通信过程。 对于安卓应用来说，Socket通信天生又分为两种Java层Socket通信和Native层Socket通信。 Java层：使用的是java.net.InetAddress、java.net.Socket、java.net.ServerSocket等类，与证书绑定的情形类似，也可能存在着自定义框架的Socket通信，这时候就需要具体情况具体分析，比如谷歌的protobuf框架等； Native层：一般使用的是C Socket API，一般hook住send()和recv()函数可以得到其发送和接受的内容 Java层Socket通信Native层Socket通信一般使用的是C Socket API，一般hook住send()和recv()函数可以得到其发送和接受的内容。udp一般使用的sendto()","link":"/2020/10/23/%E5%8F%91%E9%80%81%E4%B8%8E%E6%8E%A5%E5%8F%97%E5%87%BD%E6%95%B0/"},{"title":"抓包","text":"要想彻底解决抓包问题，必须先了解计算机网络的知识和抓包原理。 要讲计算机网络其实就不得不讲OSI七层模型。 这里就不重复赘述，详细介绍见：OSI七层模型与TCP/IP五层模型 如图，https和http在应用层，tcp和udp在传输层，socks在会话层，ip在网络层。 我们平时使用代理时，一般是通过给wifi设置http/https代理的方式进行抓包，这种抓包方式只是在应用层进行抓包。而很多包仅仅在应用层是抓不到的。此时我们要到更底层去抓，而从抓包方式来看，又分为两种。 基于中间人/流量转储的抓包： 优势：抓到的包全面、没有遗漏 劣势：遇到加密流量，得自己想办法解密，用wireshark在网络层抓包，遇到tls等只能看到密文 基于hook的抓包： 优势：抓的是加密前、解密后的数据，天生明文 劣势：不如前者全面，有些hook点难找 基于中间人/流量转储的抓包大致方式如下： 协议层 抓包方法 应用层 Charles，Fiddler使用HTTP应用层代理抓包 传输层 tcpdump工作在TCP传输层 ，Charlses socks5传输层 网络层 Wireshark工作在网卡IP的网络层 应用层HTTP/HTTPS抓包具体方法不赘述，说一些常见的检测和绕过。 两个API，查看当前系统是否挂了http代理： 12System.getProperty(“http.proxyHost”)System.getProperty(“http.proxyPort”); 网络层VPN抓包Postern + Charles https://mp.weixin.qq.com/s/a53NMP-x0qsSvjFZFm5xZw 搭建方法vpn属于网络层，设置了vpn后，手机上会多一个接口，相当于加了一个虚拟网卡，所有的流量都会从这走。应用层和传输层的请求都可以拿到，还不会被上面提及的两个api所检测。 比如使用代理APP，postern后，打开vpn服务，系统就会多一个tun0接口，如图： 路由表的第一条就指向了tun0 之后使用socks代理，将vpn连接到开启socks的抓包软件。将原本只能在应用层抓包的charles变为可以抓到网络层之上所有请求的工具。具体配置如下。 postern配置： 在配置规则中改为通过代理连接。 charles配置： 设置完之后，我们先在手机上安装charles证书，在charles界面点击Help–》SSL Proxying，里面有提示 在高版本的安卓上，用户安装的证书不会直接安装到系统根证书目录中，需要root手机后将证书移动到系统根证书目录中去。 当Charles的证书安装到系统根目录中去之后，系统就会信任来自Charles的流量包了，我们的抓包过程就会回归正常。完成后我们就可以通过中间人攻击的方式去抓取https的包了。 如果喜欢用burp，还可以加上burp 详情见：https://mp.weixin.qq.com/s/ahPbBSfkkBsv4oy265rI2Q httpCanaryhttpCanary是手机上的一个app抓包软件，采用vpn+中间人攻击的方法来抓包。 各种检验及绕过方法api检测是否开启VPN以及绕过 参考：https://mp.weixin.qq.com/s/UixExZkPWHJAT3jAD2sJJg https://www.jianshu.com/p/2476c8858daf 两个api： 12java.net.NetworkInterface.getName()android.net.ConnectivityManager.getNetworkCapabilities() 第一个api会通过java.net.NetworkInterface.getName()是否等于“tun0”或“ppp0”来判断是否存在VPN。hook该api使其返回“rmnet_data1”，即可达到过vpn检测目的。 绕过： 第二个api，android.net.ConnectivityManager.getNetworkCapabilities()样例如下，这个是api23之后才加入的函数 双向证书（Https服务器校验客户端）在许多业务非常聚焦并且当单一，比如行业应用、银行、公共交通、游戏等行业，C/S架构中服务器高度集中，对应用的版本控制非常严格，这时候就会在服务器上部署对app内置证书的校验代码。 中间人攻击中，单一通信已经分裂成两个互相独立的通信，这时候与服务器进行通信的已经不是app、而是Charles了，所以我们要将app中内置的证书导入到Charles中去。 这个操作要完成两项内容： 找到证书文件 找到证书密码 1.找证书文件：apk进行解包，直接过滤搜索后缀名为p12的文件即可，一般常用的命令为tree -NCfhl |grep -i p12。 2.找证书密码： 123456789101112131415161718function hook_KeyStore_load() { Java.perform(function () { var StringClass = Java.use(&quot;java.lang.String&quot;); var KeyStore = Java.use(&quot;java.security.KeyStore&quot;); KeyStore.load.overload('java.security.KeyStore$LoadStoreParameter').implementation = function (arg0) { printStack(&quot;KeyStore.load1&quot;); console.log(&quot;KeyStore.load1:&quot;, arg0); this.load(arg0); }; KeyStore.load.overload('java.io.InputStream', '[C').implementation = function (arg0, arg1) { printStack(&quot;KeyStore.load2&quot;); console.log(&quot;KeyStore.load2:&quot;, arg0, arg1 ? StringClass.$new(arg1) : null); this.load(arg0, arg1); }; console.log(&quot;hook_KeyStore_load...&quot;); });} 有了证书和密码之后，就可以将其导入到抓包软件中，在Charles中是位于Proxy→SSL Proxy Settings→Client Certificates→Add添加新的证书，输入指定的域名或IP使用指定的证书即可。 详细内容，见：https://www.anquanke.com/post/id/197657#h3-11 https://api-caller.com/2019/11/05/capture-note/ SSL Pinning Bypass(Https客户端代码校验服务器证书)上文中我们还有一种情况没有分析，就是客户端并不会默认信任系统根证书目录中的证书，而是在代码里再加一层校验，这就是证书绑定机制——SSL pinning，如果这段代码的校验过不了，那么客户端还是会报证书错误。 遇到这种情况的时候，我们一般有三种方式，当然目标是一样的，都是hook住这段校验的代码，使这段判断的机制失效即可。 hook住checkServerTrusted，将其所有重载都置空； 123456789101112131415function hook_ssl() { Java.perform(function() { var ClassName = &quot;com.android.org.conscrypt.Platform&quot;; var Platform = Java.use(ClassName); var targetMethod = &quot;checkServerTrusted&quot;; var len = Platform[targetMethod].overloads.length; console.log(len); for(var i = 0; i &lt; len; ++i) { Platform[targetMethod].overloads[i].implementation = function () { console.log(&quot;class:&quot;, ClassName, &quot;target:&quot;, targetMethod, &quot; i:&quot;, i, arguments); //printStack(ClassName + &quot;.&quot; + targetMethod); } } });} 使用objection，直接将SSL pinning给disable掉 1# android sslpinning disable 图2-20 使用objection的ssl pinning diable功能 如果还有一些情况没有覆盖的话，可以来看看大佬的代码 目录ObjectionUnpinningPlus增加了ObjectionUnpinning没覆盖到的锁定场景.(objection) 使用方法1 attach : frida -U com.example.mennomorsink.webviewtest2 —no-pause -l hooks.js 使用方法2 spawn : python application.py com.example.mennomorsink.webviewtest2 更为详细使用方法:参考我的文章 Frida.Android.Practice(ssl unpinning) 实战ssl pinning bypass 章节 . ObjectionUnpinningPlus hook list: SSLcontext(ART only) okhttp webview XUtils(ART only) httpclientandroidlib JSSE network_security_config (android 7.0+) Apache Http client (support partly) OpenSSLSocketImpl TrustKit 应该可以覆盖到目前已知的所有种类的证书绑定了。 网络层wireshark 手机上直接安装kali nethunter，直接在手机上跑kali运行wireshark来抓包。 制作路由器，手机连热点。 一般专门做协议这块的公司会有专门的抓包机。也就是连着网卡的虚拟机，其实和自己做路由器抓差不多 基于hook的抓包SSL双向认证抓包通用的解决办法可以用ssl_logger抓包： https://github.com/google/ssl_logger https://sec.mrfan.xyz/2019/12/16/%E5%AE%89%E5%8D%93%E6%B5%8B%E8%AF%95%E4%B9%8BHook%20SSL_read%E5%92%8CSSL_write/ https://curz0n.github.io/2020/08/15/android-ssl-and-intercept/ socket抓包当使用Charles抓包的时候，会发现针对某些IP的数据传输一直显示CONNECT，无法Complete，显示Sending request body，并且数据包大小持续增长，这时候说明我们遇到了Socket端口通信。 Socket端口通信运行在会话层，并不是应用层，Socket抓包的原理与应用层Http(s)有着显著的区别。准确的说，Http(s)抓包是真正的“中间人”抓包，而Socket抓包是在接口上进行转储；Http(s)抓包是明显的将一套C/S架构通信分裂成两套完整的通信过程，而Socket抓包是在接口上将发送与接收的内容存储下来，并不干扰其原本的通信过程。 对于安卓应用来说，Socket通信天生又分为两种Java层Socket通信和Native层Socket通信。 java层Socket通信使用的是java.net.InetAddress、java.net.Socket、java.net.ServerSocket等类，与证书绑定的情形类似，也可能存在着自定义框架的Socket通信，这时候就需要具体情况具体分析，比如谷歌的protobuf框架等； native层socket通信libc/send/recv，libssl/SSL_read/write，其中udp还可能用recvfrom()/sendto() Frida $Okhttp : 系统库，ok(3), okhttp3logging, RetrofitFrida $Java : Socket，XMPP, WEBSoket, Protobuf 抓包+逆向app分析protobuf:https://mp.weixin.qq.com/s/gMhztldG-0Xy_euX1wpZbw Frida $Native: libc/send/recv，libssl/SSL_read/write路由转储： WireShark，tcpdump，jnettop，nethogs，pcapjnettop监听所选择网络接口的流量，并以表格的形式显示当前的使用量。像“为什么我的网速这么慢呢？！”这样的问题它可以直接回答。 NetHogs 打破了网络流量按协议或子网进行统计的惯例，它以进程来分组。所以，当网络流量猛增时，你可以使用 NetHogs 查看是由哪个进程造成的。 APP访问localhost域名，NanoHTTPD服务https://www.jianshu.com/p/ecb5eb347317","link":"/2020/10/23/%E6%8A%93%E5%8C%85/"},{"title":"数据包处理","text":"stun协议去除在处理语音和视频通话时，stun的协议头会影响wireshark对于协议的解析。比如dtls如果包裹在stun协议头下面，就无法解析出相应的dtls的握手过程，从而影响到相应的动作流程的判断。 现给出学习强国的stun去除首部脚本，脚本是借助python的kamene库来实现的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990# -*- encoding: utf-8 -*-# @File : clip_stun.py# @Description : The Stun header affects wireshark parsing. So this script will help you to Remove stun headers# @Time : 2020/09/29 08:00:27# @Author : runope# @version : v1.0# Need kamene library, pip3 install kamenefrom kamene.all import *# Only clip header of stun, which obtain attribute type of data# Algorithm take advantage of data's attribute type of which Hexadecimal notation is 0x0013# and The calculated length is verifiedwith PcapReader(&quot;audio.pcap&quot;) as pcap_reader: writers = PcapWriter(&quot;audio_clip_stun_header.pcap&quot;) for pkt in pcap_reader: if 'UDP' in pkt: # read Application layer data if pkt.haslayer('Raw'): Raw = bytes(pkt['Raw']) Raw_str = '' Raw_str = Raw_str.join(['%02X' % b for b in Raw]) Raw_len = len(Raw_str) # Determine if there is any other protocol reuse if int(Raw_str[0], 16) &gt;= 4: # Throw out 4 bytes of Stun remaining = Raw_str[8:] pkt['Raw'] = bytes.fromhex(remaining) # Modify the LENGTH attribute of UDP's header UDPtemp = bytes(pkt['UDP']) UDPtemp2 = '' UDPtemp2 = UDPtemp2.join(['%02X' % b for b in UDPtemp]) UDPtemp3 = bytearray(UDPtemp) print((int(UDPtemp2[8:12], 16) - 4)) print((hex(int(UDPtemp2[8:12], 16) - 4))) j = bytearray(bytes.fromhex((hex(int(UDPtemp2[8:12], 16) - 4))[2:].zfill(4))) UDPtemp3[4] = j[0] print(j[0]) UDPtemp3[5] = j[1] print(j[1]) pkt['UDP'] = bytes(UDPtemp3) # Modify the LENGTH attribute of IP's header Iptemp = bytes(pkt['IP']) Iptemp3 = bytearray(Iptemp) Iptemp2 = '' Iptemp2 = Iptemp2.join(['%02X' % b for b in Iptemp]) print((int(Iptemp2[4:8], 16) - 4)) k = bytearray(bytes.fromhex((hex(int(Iptemp2[4:8], 16) - 4))[2:].zfill(4))) Iptemp3[2] = k[0] Iptemp3[3] = k[1] pkt['IP'] = bytes(Iptemp3) writers.write(pkt) else: # Determines whether there is a data attribute start_index = Raw_str.find(&quot;0013&quot;) # Extract the data for the data attribute if start_index != -1: remaining = Raw_str[start_index:] remaining_length = int(remaining[4:8],16) remaining = remaining[8:] # 4-byte alignment, slove the error by padding if len(remaining) // 8 == (remaining_length + 3) // 4: pkt['Raw'] = bytes.fromhex(remaining[0:remaining_length*2]) sub_len = (Raw_len - remaining_length*2) // 2 # Modify the LENGTH attribute of UDP's header UDPtemp = bytes(pkt['UDP']) UDPtemp2 = bytearray(UDPtemp) UDPtemp2[5] = UDPtemp2[5] - sub_len UDPtemp3 = bytes(UDPtemp2) pkt['UDP'] = UDPtemp3 # Modify the LENGTH attribute of IP's header Iptemp = bytes(pkt['IP']) Iptemp2 = bytearray(Iptemp) Iptemp2[3] = Iptemp2[3] - sub_len Iptemp3 = bytes(Iptemp2) pkt['IP'] = Iptemp3 writers.write(pkt) else: writers.write(pkt) writers.flush() writers.close() 效果如下图： 去除首部前 去除首部后","link":"/2020/10/23/%E6%95%B0%E6%8D%AE%E5%8C%85%E5%A4%84%E7%90%86/"},{"title":"frida打印与参数构造","text":"本文将系统讨论，frida的打印与参数构造问题。 参数打印bytes2Hex12345678910111213141516171819202122function bytes2Hex(arrBytes){ var str = &quot;&quot;; for (var i = 0; i &lt; arrBytes.length; i++) { var tmp; var num = arrBytes[i]; if (num &lt; 0) { //此处填坑，当byte因为符合位导致数值为负时候，需要对数据进行处理 tmp = (255 + num + 1).toString(16); } else { tmp = num.toString(16); } if (tmp.length == 1) { tmp = &quot;0&quot; + tmp; } if(i&gt;0){ str += &quot; &quot;+tmp; }else{ str += tmp; } } return str;} 传入的参数为byte[],example：[12, 0, 156, -127] return:[0c,00,9c,fe],注意别传成了string。 string2Bytes123456789101112131415161718192021222324252627function string2Bytes(str) { var bytes = new Array(); var len, c; len = str.length; for(var i = 0; i &lt; len; i++) { c = str.charCodeAt(i); if(c &gt;= 0x010000 &amp;&amp; c &lt;= 0x10FFFF) { bytes.push(((c &gt;&gt; 18) &amp; 0x07) | 0xF0); bytes.push(((c &gt;&gt; 12) &amp; 0x3F) | 0x80); bytes.push(((c &gt;&gt; 6) &amp; 0x3F) | 0x80); bytes.push((c &amp; 0x3F) | 0x80); } else if(c &gt;= 0x000800 &amp;&amp; c &lt;= 0x00FFFF) { bytes.push(((c &gt;&gt; 12) &amp; 0x0F) | 0xE0); bytes.push(((c &gt;&gt; 6) &amp; 0x3F) | 0x80); bytes.push((c &amp; 0x3F) | 0x80); } else if(c &gt;= 0x000080 &amp;&amp; c &lt;= 0x0007FF) { bytes.push(((c &gt;&gt; 6) &amp; 0x1F) | 0xC0); bytes.push((c &amp; 0x3F) | 0x80); } else { bytes.push(c &amp; 0xFF); } } return bytes;} bytes2String1234567891011121314151617181920212223242526272829303132333435 function bytes2String(arr) { if(typeof arr === 'string') { return arr; } var str = '', _arr = arr; for(var i = 0; i &lt; _arr.length; i++) { var one = _arr[i].toString(2), v = one.match(/^1+?(?=0)/); if(v &amp;&amp; one.length == 8) { var bytesLength = v[0].length; var store = _arr[i].toString(2).slice(7 - bytesLength); for(var st = 1; st &lt; bytesLength; st++) { store += _arr[st + i].toString(2).slice(2); } try { str += String.fromCharCode(parseInt(store, 2)); } catch (error) { str += parseInt(store, 2).toString(); console.log(error); } i += bytesLength - 1; } else { try { str += String.fromCharCode(_arr[i]); } catch (error) { str += parseInt(store, 2).toString(); console.log(error); } } } return str;} 这个脚本没问题，在chrome的console中随便用，但是在frida script中如果不是在unicode的解码范围内会报错，所以我直接用的python解的byte2string.后面那个通过java string函数的转换可以直接用BytesToString BytesToString12345function bytesToString(value) { var buffer = Java.array('byte', value); var StringClass = Java.use('java.lang.String'); return StringClass.$new(buffer);} char[]123456789101112131415Java.openClassFile(&quot;/data/local/tmp/r0gson.dex&quot;).load();const gson = Java.use('com.r0ysue.gson.Gson');Java.use(&quot;java.lang.Character&quot;).toString.overload('char').implementation = function(char){ var result = this.toString(char); console.log(&quot;char,result&quot;,char,result); return result;}Java.use(&quot;java.util.Arrays&quot;).toString.overload('[C').implementation = function(charArray){ var result = this.toString(charArray); console.log(&quot;charArray,result:&quot;,charArray,result) console.log(&quot;charArray Object Object:&quot;,gson.$new().toJson(charArray)); return result;} byte[]使用google的gson库，来辅助构造，为防止app已包含此库并混淆，干扰我们调用，将该库提取出来，改名。 12下载链接：https://raw.githubusercontent.com/r0ysue/AndroidSecurityStudy/master/FRIDA/r0gson.dex.zip把文件push到系统和frida-server放在一起 使用方法： 123456789Java.openClassFile(&quot;/data/local/tmp/r0gson.dex&quot;).load();const gson = Java.use('com.r0ysue.gson.Gson');Java.use(&quot;java.util.Arrays&quot;).toString.overload('[B').implementation = function(byteArray){ var result = this.toString(byteArray); console.log(&quot;byteArray,result):&quot;,byteArray,result) console.log(&quot;byteArray Object Object:&quot;,gson.$new().toJson(byteArray)); return result;} ByteBuffer12345678910111213141516171819202122232425262728293031323334Java.openClassFile(&quot;/data/local/tmp/r0gson.dex&quot;).load();const gson = Java.use('com.r0ysue.gson.Gson');my_class.b.overload('java.nio.ByteBuffer', 'java.nio.ByteBuffer').implementation = function(x0,x1) { var result = this.b(x0,x1); //Suppose the byte[] in the Bytebuffer has a key value of 'hb'. var bytesArray = bytesBuffer2bytesArray(x0, 'hb'); var tmp = gson.$new().toJson(x0); tmp = JSON.parse(tmp); console.log(&quot;tmp:&quot;+typeof(tmp)); console.log(&quot;decrypt --&gt; message: &quot;,tmp[&quot;backingArray&quot;]); // console.log(&quot;decrypt --&gt; message*hexdump: &quot;,hexdump(gson.$new().toJson(x0)[&quot;backingArray&quot;])); // console.log(&quot;decrypt --&gt; decryptTo: &quot;,gson.$new().toJson(x1)); // console.log(&quot;decrypt --&gt; decryptTo*hexdump: &quot;,hexdump(gson.$new().toJson(x1)[&quot;backingArray&quot;])); return result;}function bytesBuffer2bytesArray(bytesBuffer, key) { Java.openClassFile(&quot;/data/local/tmp/r0gson.dex&quot;).load(); const gson = Java.use('com.r0ysue.gson.Gson'); var tmp = gson.$new().toJson(bytesBuffer); var dataKey = key tmp = JSON.parse(tmp); tmp = new Array(tmp[dataKey]); tmp = tmp.toString(); var tmp_array = tmp.split(&quot;,&quot;); var tmp_int_array=[]; tmp_int_array=tmp_array.map(function(data){ return +data; }); return tmp_int_array} example下面给一个样例，hook的xxqg的chacha20poly1305算法。 python： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import timeimport fridaimport sysimport binasciidef on_message(message , data): #定义错误处理 if message['type'] == 'send': # print(&quot;[*] {0}&quot;.format(message['payload'])) print() hex_str = message['payload'] hex_str_len = len(hex_str) // 这个包尾部的0x00有点多，看着不舒服，所以这个是去除尾部00的空bytebuffer的 n_0 = 0 for k in hex_str[::-1]: if k == '0': n_0 += 1 else: break print(hex_str[0:hex_str_len-n_0]) n_0 = n_0//2 hex_str_remove_zero = hex_str for i in range(0,hex_str_len//2-n_0): // 这里是核心的bytes[] to string，这里一个个字符解，以及try/catch都是为了防止不可见编码影响效果 try: hex0 = hex_str[2*i:2*i+2].encode('utf-8') str_bin = binascii.unhexlify(hex0) print(str_bin.decode('utf-8'),end=&quot;&quot;) except: pass # file.write(&quot;[*] {0}&quot;.format(message['payload'])) else: print(message) # file.write(message)# 连接安卓机上的frida-serverdevice = frida.get_usb_device()# 启动apppid = device.spawn([&quot;cn.xuexi.android&quot;])device.resume(pid)time.sleep(1)session = device.attach(pid)# 加载脚本with open(&quot;./xxqg.js&quot;,encoding='UTF-8') as f: script = session.create_script(f.read())script.on(&quot;message&quot; , on_message) #调用错误处理script.load()# 脚本会持续运行等待输入sys.stdin.read() JavaScript： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165console.log(&quot;Script loaded successfully &quot;);Java.perform(function x() { console.log(&quot;Inside java perform function&quot;); var my_class = Java.use(&quot;com.laiwang.protocol.android.x&quot;); console.log(&quot;Java.Use.Successfully!&quot;);//定位类成功！ //在这里更改类的方法的实现（implementation） console.log(&quot;Inside java perform function&quot;); Java.openClassFile(&quot;/data/local/tmp/r0gson.dex&quot;).load(); const gson = Java.use('com.r0ysue.gson.Gson'); my_class.b.overload('java.nio.ByteBuffer', 'java.nio.ByteBuffer').implementation = function(x0,x1) { var result = this.b(x0,x1); var bytesArray = bytesBuffer2bytesArray(x1, 'hb'); send(bytes2Hex_nin_zero(bytesArray)); return result; } my_class.a.overload('java.nio.ByteBuffer', 'java.nio.ByteBuffer').implementation = function(x0,x1) { var result = this.a(x0,x1); var bytesArray = bytesBuffer2bytesArray(x0, 'hb'); send(bytes2Hex_nin_zero(bytesArray)); return result; }})function bytesBuffer2bytesArray(bytesBuffer, key) { Java.openClassFile(&quot;/data/local/tmp/r0gson.dex&quot;).load(); const gson = Java.use('com.r0ysue.gson.Gson'); var tmp = gson.$new().toJson(bytesBuffer); var dataKey = key tmp = JSON.parse(tmp); tmp = new Array(tmp[dataKey]); tmp = tmp.toString(); var tmp_array = tmp.split(&quot;,&quot;); var tmp_int_array=[]; tmp_int_array=tmp_array.map(function(data){ return +data; }); return tmp_int_array}function bytes2Hex(arrBytes){ var str = &quot;&quot;; for (var i = 0; i &lt; arrBytes.length; i++) { var tmp; var num = arrBytes[i]; if (num &lt; 0) { //此处填坑，当byte因为符合位导致数值为负时候，需要对数据进行处理 tmp = (255 + num + 1).toString(16); } else { tmp = num.toString(16); } if (tmp.length == 1) { tmp = &quot;0&quot; + tmp; } if(i&gt;0){ str += &quot; &quot;+tmp; }else{ str += tmp; } } return str;}function bytes2Hex_nin_zero(arrBytes){ var str = &quot;&quot;; for (var i = 0; i &lt; arrBytes.length; i++) { var tmp; var num = arrBytes[i]; if (num &lt; 0) { //此处填坑，当byte因为符合位导致数值为负时候，需要对数据进行处理 tmp = (255 + num + 1).toString(16); } else { tmp = num.toString(16); } if (tmp.length == 1) { tmp = &quot;0&quot; + tmp; } if(i&gt;0){ str += &quot;&quot;+tmp; }else{ str += tmp; } } return str;}function string2Bytes(str) { var bytes = new Array(); var len, c; len = str.length; for(var i = 0; i &lt; len; i++) { c = str.charCodeAt(i); if(c &gt;= 0x010000 &amp;&amp; c &lt;= 0x10FFFF) { bytes.push(((c &gt;&gt; 18) &amp; 0x07) | 0xF0); bytes.push(((c &gt;&gt; 12) &amp; 0x3F) | 0x80); bytes.push(((c &gt;&gt; 6) &amp; 0x3F) | 0x80); bytes.push((c &amp; 0x3F) | 0x80); } else if(c &gt;= 0x000800 &amp;&amp; c &lt;= 0x00FFFF) { bytes.push(((c &gt;&gt; 12) &amp; 0x0F) | 0xE0); bytes.push(((c &gt;&gt; 6) &amp; 0x3F) | 0x80); bytes.push((c &amp; 0x3F) | 0x80); } else if(c &gt;= 0x000080 &amp;&amp; c &lt;= 0x0007FF) { bytes.push(((c &gt;&gt; 6) &amp; 0x1F) | 0xC0); bytes.push((c &amp; 0x3F) | 0x80); } else { bytes.push(c &amp; 0xFF); } } return bytes;} function bytes2String(arr) { if(typeof arr === 'string') { return arr; } var str = '', _arr = arr; for(var i = 0; i &lt; _arr.length; i++) { var one = _arr[i].toString(2), v = one.match(/^1+?(?=0)/); if(v &amp;&amp; one.length == 8) { var bytesLength = v[0].length; var store = _arr[i].toString(2).slice(7 - bytesLength); for(var st = 1; st &lt; bytesLength; st++) { store += _arr[st + i].toString(2).slice(2); } try { str += String.fromCharCode(parseInt(store, 2)); } catch (error) { str += parseInt(store, 2).toString(); console.log(error); } i += bytesLength - 1; } else { try { str += String.fromCharCode(_arr[i]); } catch (error) { str += parseInt(store, 2).toString(); console.log(error); } } } return str;} hexdump1234567891011121314151617181920212223242526272829303132333435363738var _fillUp = function (value, count, fillWith) { var l = count - value.length; var ret = &quot;&quot;; while (--l &gt; -1) ret += fillWith; return ret + value;}hexdump = function (arrayBuffer, offset, length) { var view = new DataView(arrayBuffer); offset = offset || 0; length = length || arrayBuffer.byteLength; var out = _fillUp(&quot;Offset&quot;, 8, &quot; &quot;) + &quot; 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F\\n&quot;; var row = &quot;&quot;; for (var i = 0; i &lt; length; i += 16) { row += _fillUp(offset.toString(16).toUpperCase(), 8, &quot;0&quot;) + &quot; &quot;; var n = Math.min(16, length - offset); var string = &quot;&quot;; for (var j = 0; j &lt; 16; ++j) { if (j &lt; n) { var value = view.getUint8(offset); string += value &gt;= 32 ? String.fromCharCode(value) : &quot;.&quot;; row += _fillUp(value.toString(16).toUpperCase(), 2, &quot;0&quot;) + &quot; &quot;; offset++; } else { row += &quot; &quot;; string += &quot; &quot;; } } row += &quot; &quot; + string + &quot;\\n&quot;; } out += row; return out;}; 打印non-asciihttps://api-caller.com/2019/03/30/frida-note/#non-ascii类名非ASCII字符串时，先编码打印出来, 再用编码后的字符串去 hook. 1234567891011121314//场景hook cls.forName寻找目标类的classloader。 cls.forName.overload('java.lang.String', 'boolean', 'java.lang.ClassLoader').implementation = function (arg1, arg2, arg3) { var clsName = cls.forName(arg1, arg2, arg3); console.log('oriClassName:' + arg1) var base64Name = encodeURIComponent(arg1) console.log('encodeName:' + base64Name); //通过日志确认base64后的非ascii字符串，下面对比并打印classloader //clsName为特殊字符o.ÎÉ« if ('o.%CE%99%C9%AB' == base64Name) { //打印classloader console.log(arg3); } return clsName; } hook enum1234567891011121314151617181920enum Signal { GREEN, YELLOW, RED}public class TrafficLight { public static Signal color = Signal.RED; public static void main() { Log.d(&quot;4enum&quot;, &quot;enum &quot;+ color.getClass().getName().toString()); switch (color) { case RED: color = Signal.GREEN; break; case YELLOW: color = Signal.RED; break; case GREEN: color = Signal.YELLOW; break; } }} 12345678910Java.perform(function(){ Java.choose(&quot;com.r0ysue.a0526printout.Signal&quot;,{ onMatch:function(instance){ console.log(&quot;instance.name:&quot;,instance.name()); console.log(&quot;instance.getDeclaringClass:&quot;,instance.getDeclaringClass()); },onComplete:function(){ console.log(&quot;search completed!&quot;) } }) }) 打印hash map1234567891011Java.perform(function(){ Java.choose(&quot;java.util.HashMap&quot;,{ onMatch:function(instance){ if(instance.toString().indexOf(&quot;ISBN&quot;)!= -1){ console.log(&quot;instance.toString:&quot;,instance.toString()); } },onComplete:function(){ console.log(&quot;search complete!&quot;) } }) }) 参数构造Java array构造如果不只是想打印出结果，而是要替换原本的参数，就要先自己构造出一个charArray,使用Java.arrayAPI 12345678Java.use(&quot;java.util.Arrays&quot;).toString.overload('[C').implementation = function(charArray){ var newCharArray = Java.array('char', [ '一','去','二','三','里' ]); var result = this.toString(newCharArray); console.log(&quot;newCharArray,result:&quot;,newCharArray,result) console.log(&quot;newCharArray Object Object:&quot;,gson.$new().toJson(newCharArray)); var newResult = Java.use('java.lang.String').$new(Java.array('char', [ '烟','村','四','五','家'])) return newResult;} 类的多态：转型/Java.cast可以通过getClass().getName().toString()来查看当前实例的类型。找到一个instance，通过Java.cast来强制转换对象的类型。 1234567891011121314151617181920public class Water { // 水 类 public static String flow(Water W) { // 水 的方法 // SomeSentence Log.d(&quot;2Object&quot;, &quot;water flow: I`m flowing&quot;); return &quot;water flow: I`m flowing&quot;; } public String still(Water W) { // 水 的方法 // SomeSentence Log.d(&quot;2Object&quot;, &quot;water still: still water runs deep!&quot;); return &quot;water still: still water runs deep!&quot;; }}...public class Juice extends Water { // 果汁 类 继承了水类 public String fillEnergy(){ Log.d(&quot;2Object&quot;, &quot;Juice: i`m fillingEnergy!&quot;); return &quot;Juice: i`m fillingEnergy!&quot;; } 12345678910111213var JuiceHandle = null ;Java.choose(&quot;com.r0ysue.a0526printout.Juice&quot;,{ onMatch:function(instance){ console.log(&quot;found juice instance&quot;,instance); console.log(&quot;juice instance call fill&quot;,instance.fillEnergy()); JuiceHandle = instance; },onComplete:function(){ console.log(&quot;juice handle search completed!&quot;) }})console.log(&quot;Saved juice handle :&quot;,JuiceHandle);var WaterHandle = Java.cast(JuiceHandle,Java.use(&quot;com.r0ysue.a0526printout.Water&quot;))console.log(&quot;call Waterhandle still method:&quot;,WaterHandle.still(WaterHandle)); interface/Java.registerClassfrida可以构建一个新的class 123public interface liquid { public String flow();} 首先获取要实现的interface，然后调用registerClass来实现interface。 1234567891011121314Java.perform(function(){ var liquid = Java.use(&quot;com.r0ysue.a0526printout.liquid&quot;); var beer = Java.registerClass({ name: 'com.r0ysue.a0526printout.beer', implements: [liquid], methods: { flow: function () { console.log(&quot;look, beer is flowing!&quot;) return &quot;look, beer is flowing!&quot;; } } }); console.log(&quot;beer.bubble:&quot;,beer.$new().flow()) })","link":"/2020/10/23/frida%E6%89%93%E5%8D%B0%E4%B8%8E%E5%8F%82%E6%95%B0%E6%9E%84%E9%80%A0%E9%97%AE%E9%A2%98/"}],"tags":[{"name":"so","slug":"so","link":"/tags/so/"},{"name":"逆向","slug":"逆向","link":"/tags/%E9%80%86%E5%90%91/"},{"name":"trace","slug":"trace","link":"/tags/trace/"},{"name":"kali","slug":"kali","link":"/tags/kali/"},{"name":"工具","slug":"工具","link":"/tags/%E5%B7%A5%E5%85%B7/"},{"name":"blog","slug":"blog","link":"/tags/blog/"},{"name":"Socket","slug":"Socket","link":"/tags/Socket/"},{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"抓包","slug":"抓包","link":"/tags/%E6%8A%93%E5%8C%85/"},{"name":"协议分析","slug":"协议分析","link":"/tags/%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/"},{"name":"frida","slug":"frida","link":"/tags/frida/"},{"name":"HOOK","slug":"HOOK","link":"/tags/HOOK/"}],"categories":[{"name":"逆向与协议分析","slug":"逆向与协议分析","link":"/categories/%E9%80%86%E5%90%91%E4%B8%8E%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/"},{"name":"trace","slug":"trace","link":"/categories/trace/"},{"name":"kali","slug":"kali","link":"/categories/kali/"},{"name":"blog","slug":"blog","link":"/categories/blog/"},{"name":"linux","slug":"linux","link":"/categories/linux/"}]}